#jinja2: trim_blocks:True, lstrip_blocks: True
#!/bin/bash

#
# Script to configure an iptables based firewall using a template from an Ansible playbook role "iptables".
# DO NOT EDIT this file manually; edit the the template instead and redeploy using Ansible!
#
# This file must be located in /etc/sysconfig/iptables-init.bash 
#

#
# Bash sanity.
#
set -u

#
# Hosts and interfaces.
#
TARGET_SERVER='{{ ansible_hostname }}'
declare -a INTERNAL_INTERFACES=(
{% for internal_interface in internal_interfaces %}
	'{{ internal_interface }}'
{% endfor %}
)
declare -a EXTERNAL_INTERFACES=(
{% for external_interface in external_interfaces %}
	'{{ external_interface }}'
{% endfor %}
)
LOOPBACK='127.0.0.0/8'

#
##
### Main.
##
#

#
# Get (short) name of the server where this script is executed.
#  * Ignore the domain.
#  * Remove any -mgmt suffixes
#
SERVER_NAME="$(hostname -s)"

#
# Check if we have a config valid for this server.
#
if [[ "${SERVER_NAME%-mgmt}" == "${TARGET_SERVER}" ]]; then
	echo "INFO: Hostname check passed. Will configure iptables firewall..."
else
	echo "ERROR: This config file is for \"${TARGET_SERVER}\", but this is \"${SERVER_NAME%-mgmt}\"."
	echo 'FATAL: Cannot configure firewall on this server.'
	exit 1
fi

#
##
### IPv6: disable all and log.
##
#

#
# Flush and delete existing rules.
#
ip6tables -F
ip6tables -X

#
# Create custom chain for LOGDROP.
#
ip6tables -N LOGDROP
ip6tables -A LOGDROP -m limit --limit 15/minute -j LOG --log-level 7 --log-prefix 'Dropped by ip6tables: '
ip6tables -A LOGDROP -j DROP

#
# Set the default policies to drop everything.
#
{% if iptables_log_dropped_packets %}
ip6tables -P INPUT   LOGDROP
{% else %}
ip6tables -P INPUT   DROP
{% endif %}
ip6tables -P OUTPUT DROP
ip6tables -P FORWARD DROP

#
# We must accept IPv6 traffic on the loopback interface to prevent tests from failing
# during installation of various software packages with network functionality.
#
ip6tables -A INPUT  -i lo -j ACCEPT
ip6tables -A OUTPUT -o lo -j ACCEPT

#
##
### IPv4.
##
#

#
# Initialize and flush everything to start with a clean slate.
#
iptables -F
iptables -X
iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X
iptables -t raw -F
iptables -t raw -X
iptables -t security -F
iptables -t security -X
iptables -Z

#
# Create custom chain for LOGDROP.
#
iptables -N LOGDROP
iptables -A LOGDROP -m limit --limit 15/minute -j LOG --log-level 7 --log-prefix 'Dropped by iptables: '
iptables -A LOGDROP -j DROP

#
# Set default policies to drop everything.
#
{% if iptables_log_dropped_packets %}
iptables -P INPUT   LOGDROP
{% else %}
iptables -P INPUT   DROP
{% endif %}
iptables -P OUTPUT  DROP
iptables -P FORWARD DROP

#
# Refuse loopback packets incoming from external interface.
#
for EXT_INTERFACE in "${EXTERNAL_INTERFACES[@]:-}"; do
	[[ -z "${EXT_INTERFACE}" ]] && continue
	iptables -A INPUT -i "${EXT_INTERFACE}" -d "${LOOPBACK}" -j DROP
done

#
# Allow anything over internal interfaces including the loopback interface.
#
for INT_INTERFACE in "${INTERNAL_INTERFACES[@]:-}"; do
	[[ -z "${INT_INTERFACE}" ]] && continue
	iptables -A INPUT  -i "${INT_INTERFACE}" -j ACCEPT
	iptables -A OUTPUT -o "${INT_INTERFACE}" -j ACCEPT
done

#
# Filter traffic over external interfaces.
#
for EXT_INTERFACE in "${EXTERNAL_INTERFACES[@]:-}"; do
	[[ -z "${EXT_INTERFACE}" ]] && continue
	#
	# Allow all outbound ICMP.
	#
	iptables -A OUTPUT -o "${EXT_INTERFACE}" -p icmp -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
	iptables -A INPUT  -i "${EXT_INTERFACE}" -p icmp -m state --state ESTABLISHED,RELATED     -j ACCEPT
{% if iptables_allow_icmp_inbound is defined and iptables_allow_icmp_inbound | length > 0 %}
	#
	# Allow limited inbound ICMP:
	#    Type 0    Echo Reply   (a.k.a. pong) must be RELATED.
	#    Type 8    Echo Request (a.k.a. ping)
	#    Type 3    Destination Unreachable:
	#              Unable to deliver the datagram to the specified network, host, protocal, or port.
	#              Also sent if the datagram needs to be fragmented and the the Don't Fragment flag is on.
	#              Required for Path-MTU Discovery and to prevent a PMTU "black hole".
	#    Type 11   Time Exceeded:
	#              The Time To Live (TTL) for the datagram has been exceeded.
	#              Required for traceroute.
	#
	declare -a ALLOW_ICMP_INBOUND=(
	{% for ip in iptables_allow_icmp_inbound %}
		{% if ip == 'ANY'%}
		'0.0.0.0/0'
		{% else %}
		'{{ ip.address }}{{ ip.netmask }}'{% if ip.fqdn is defined and ip.fqdn != "NXDOMAIN" %}	# {{ ip.fqdn }}{% elif ip.desc is defined %}	# {{ ip.desc }}{% endif +%}
		{% endif %}
	{% endfor %}
	)
	for IP_ADDRESS in "${ALLOW_ICMP_INBOUND[@]}"; do
		iptables -A INPUT  -i "${EXT_INTERFACE}" -p icmp --icmp-type 3  -s "${IP_ADDRESS}" -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
		iptables -A INPUT  -i "${EXT_INTERFACE}" -p icmp --icmp-type 8  -s "${IP_ADDRESS}" -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
		iptables -A INPUT  -i "${EXT_INTERFACE}" -p icmp --icmp-type 11 -s "${IP_ADDRESS}" -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT
	done
{% endif%}
	#
	# Allow outbound NTP.
	#
	iptables -A OUTPUT -o "${EXT_INTERFACE}" -p udp --dport 123 -m state --state NEW,ESTABLISHED -j ACCEPT
	iptables -A INPUT  -i "${EXT_INTERFACE}" -p udp --sport 123 -m state --state ESTABLISHED     -j ACCEPT
	#
	# Allow outbound SMTP.
	#
	iptables -A OUTPUT -o "${EXT_INTERFACE}" -p tcp -m multiport --dports 25,587 -m state --state NEW,ESTABLISHED -j ACCEPT
	iptables -A INPUT  -i "${EXT_INTERFACE}" -p tcp -m multiport --sports 25,587 -m state --state ESTABLISHED     -j ACCEPT
	#
	# Allow outbound DNS.
	#
	iptables -A OUTPUT -o "${EXT_INTERFACE}" -p udp --dport 53 -m state --state NEW,ESTABLISHED -j ACCEPT
	iptables -A INPUT  -i "${EXT_INTERFACE}" -p udp --sport 53 -m state --state ESTABLISHED     -j ACCEPT
	iptables -A OUTPUT -o "${EXT_INTERFACE}" -p tcp --dport 53 -m state --state NEW,ESTABLISHED -j ACCEPT
	iptables -A INPUT  -i "${EXT_INTERFACE}" -p tcp --sport 53 -m state --state ESTABLISHED     -j ACCEPT
	#
	# Allow outbound LDAPS.
	#
	iptables -A OUTPUT -o "${EXT_INTERFACE}" -p tcp --dport 636 -m state --state NEW,ESTABLISHED -j ACCEPT
	iptables -A INPUT  -i "${EXT_INTERFACE}" -p tcp --sport 636 -m state --state ESTABLISHED     -j ACCEPT
	#
	# Allow outbound HTTP.
	#
	iptables -A OUTPUT -o "${EXT_INTERFACE}" -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT
	iptables -A INPUT  -i "${EXT_INTERFACE}" -p tcp --sport 80 -m state --state ESTABLISHED     -j ACCEPT
{% if iptables_allow_http_inbound is defined and iptables_allow_http_inbound | length > 0 %}
	#
	# Allow inbound HTTP.
	#
	declare -a ALLOW_HTTP_INBOUND=(
	{% for ip in iptables_allow_http_inbound %}
		{% if ip == 'ANY'%}
		'0.0.0.0/0'
		{% else %}
		'{{ ip.address }}{{ ip.netmask }}'{% if ip.fqdn is defined and ip.fqdn != "NXDOMAIN" %}	# {{ ip.fqdn }}{% elif ip.desc is defined %}	# {{ ip.desc }}{% endif +%}
		{% endif %}
	{% endfor %}
	)
	for IP_ADDRESS in "${ALLOW_HTTP_INBOUND[@]}"; do
		iptables -A INPUT  -i "${EXT_INTERFACE}" -p tcp -s "${IP_ADDRESS}" --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT
	done
	iptables -A OUTPUT -o "${EXT_INTERFACE}" -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT
{% endif%}
	#
	# Allow outbound HTTPS.
	#
	iptables -A OUTPUT -o "${EXT_INTERFACE}" -p tcp --dport 443 -m state --state NEW,ESTABLISHED -j ACCEPT
	iptables -A INPUT  -i "${EXT_INTERFACE}" -p tcp --sport 443 -m state --state ESTABLISHED     -j ACCEPT
{% if iptables_allow_https_inbound is defined and iptables_allow_https_inbound | length > 0 %}
	#
	# Allow inbound HTTPS.
	#
	declare -a ALLOW_HTTPS_INBOUND=(
	{% for ip in iptables_allow_https_inbound %}
		{% if ip == 'ANY'%}
		'0.0.0.0/0'
		{% else %}
		'{{ ip.address }}{{ ip.netmask }}'{% if ip.fqdn is defined and ip.fqdn != "NXDOMAIN" %}	# {{ ip.fqdn }}{% elif ip.desc is defined %}	# {{ ip.desc }}{% endif +%}
		{% endif %}
	{% endfor %}
	)
	for IP_ADDRESS in "${ALLOW_HTTPS_INBOUND[@]}"; do
		iptables -A INPUT  -i "${EXT_INTERFACE}" -p tcp -s "${IP_ADDRESS}" --dport 443 -m state --state NEW,ESTABLISHED -j ACCEPT
	done
	iptables -A OUTPUT -o "${EXT_INTERFACE}" -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEPT
{% endif%}
{% if iptables_allow_ssh_inbound is defined and iptables_allow_ssh_inbound | length > 0 %}
	#
	# Allow SSH inbound.
	#
	declare -a ALLOW_SSH_INBOUND=(
	{% for ip in iptables_allow_ssh_inbound %}
		{% if ip == 'ANY'%}
		'0.0.0.0/0'
		{% else %}
		'{{ ip.address }}{{ ip.netmask }}'{% if ip.fqdn is defined and ip.fqdn != "NXDOMAIN" %}	# {{ ip.fqdn }}{% elif ip.desc is defined %}	# {{ ip.desc }}{% endif +%}
		{% endif %}
	{% endfor %}
	)
	for IP_ADDRESS in "${ALLOW_SSH_INBOUND[@]}"; do
		iptables -A INPUT  -i "${EXT_INTERFACE}" -p tcp -s "${IP_ADDRESS}" --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT
	done
	iptables -A OUTPUT -o "${EXT_INTERFACE}" -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT
{% endif%}
{% if iptables_allow_ssh_outbound is defined and iptables_allow_ssh_outbound | length > 0 %}
	#
	# Allow SSH outbound.
	#
	declare -a ALLOW_SSH_OUTBOUND=(
	{% for ip in iptables_allow_ssh_outbound %}
		{% if ip == 'ANY'%}
		'0.0.0.0/0'
		{% else %}
		'{{ ip.address }}{{ ip.netmask }}'{% if ip.fqdn is defined and ip.fqdn != "NXDOMAIN" %}	# {{ ip.fqdn }}{% elif ip.desc is defined %}	# {{ ip.desc }}{% endif +%}
		{% endif %}
	{% endfor %}
	)
	for IP_ADDRESS in "${ALLOW_SSH_OUTBOUND[@]}"; do
		iptables -A OUTPUT -o "${EXT_INTERFACE}" -p tcp -d "${IP_ADDRESS}" --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT
	done
	iptables -A INPUT  -i "${EXT_INTERFACE}" -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT
{% endif%}
{% if iptables_allow_ebi_mysql_outbound is defined and iptables_allow_ebi_mysql_outbound | length > 0 %}
	#
	# Allow MySQL outbound.
	#
	# Required a.o. for connections to the public Ensembl databases via the Ensembl Perl API
	#
	declare -a ALLOW_EBI_MYSQL_OUTBOUND=(
	{% for ip in iptables_allow_ebi_mysql_outbound %}
		{% if ip == 'ANY'%}
		'0.0.0.0/0'
		{% else %}
		'{{ ip.address }}{{ ip.netmask }}'{% if ip.fqdn is defined and ip.fqdn != "NXDOMAIN" %}	# {{ ip.fqdn }}{% elif ip.desc is defined %}	# {{ ip.desc }}{% endif +%}
		{% endif %}
	{% endfor %}
	)
	for IP_ADDRESS in "${ALLOW_EBI_MYSQL_OUTBOUND[@]}"; do
		iptables -A OUTPUT -o "${EXT_INTERFACE}" -p tcp -d "${IP_ADDRESS}" -m multiport --dports 3306,5306,5316 -m state --state NEW,ESTABLISHED -j ACCEPT
	done
	iptables -A INPUT -i "${EXT_INTERFACE}" -p tcp -m multiport --sports 3306,5306,5316 -m state --state ESTABLISHED -j ACCEPT
{% endif%}
{% if iptables_allow_postgresql_outbound is defined and iptables_allow_postgresql_outbound | length > 0 %}
	#
	# Allow PostgreSQL outbound.
	#
	declare -a ALLOW_POSTGRESQL_OUTBOUND=(
	{% for ip in iptables_allow_postgresql_outbound %}
		{% if ip == 'ANY'%}
		'0.0.0.0/0'
		{% else %}
		'{{ ip.address }}{{ ip.netmask }}'{% if ip.fqdn is defined and ip.fqdn != "NXDOMAIN" %}	# {{ ip.fqdn }}{% elif ip.desc is defined %}	# {{ ip.desc }}{% endif +%}
		{% endif %}
	{% endfor %}
	)
	for IP_ADDRESS in "${ALLOW_POSTGRESQL_OUTBOUND[@]}"; do 
		iptables -A OUTPUT -o "${EXT_INTERFACE}" -p tcp -d "${IP_ADDRESS}" --dport 5432 -m state --state NEW,ESTABLISHED -j ACCEPT
	done
	iptables -A INPUT -i "${EXT_INTERFACE}" -p tcp --sport 5432 -m state --state ESTABLISHED -j ACCEPT
{% endif%}
{% if iptables_allow_ftp_outbound is defined and iptables_allow_ftp_outbound | length > 0 %}
	#
	# Allow FTP outbound.
	#
	# We need a default and an additional connection tracking kernel module 
	# in order to track FTP connections and know what is a RELATED connection.
	# The extra module must be added to /etc/sysconfig/iptables-config
	#    IPTABLES_MODULES="nf_conntrack_ftp"
	#
	declare -a ALLOW_FTP_OUTBOUND=(
	{% for ip in iptables_allow_ftp_outbound %}
		{% if ip == 'ANY'%}
		'0.0.0.0/0'
		{% else %}
		'{{ ip.address }}{{ ip.netmask }}'{% if ip.fqdn is defined and ip.fqdn != "NXDOMAIN" %}	# {{ ip.fqdn }}{% elif ip.desc is defined %}	# {{ ip.desc }}{% endif +%}
		{% endif %}
	{% endfor %}
	)
	/sbin/modprobe nf_conntrack     # Default module: should already be present, just checking here.
	/sbin/modprobe nf_conntrack_ftp # Extra module: should be added to /etc/sysconfig/iptables-config, just checking here.
	#
	# Firstly, allow FTP control initiated by the client.
	#
	for IP_ADDRESS in "${ALLOW_FTP_OUTBOUND[@]}"; do
		iptables -A OUTPUT -o "${EXT_INTERFACE}" -p tcp -d "${IP_ADDRESS}" --dport 21 -m state --state NEW,ESTABLISHED -j ACCEPT
	done
	iptables -A INPUT -i "${EXT_INTERFACE}" -p tcp --sport 21 -m state --state ESTABLISHED -j ACCEPT
	#
	# Secondly, allow FTP data connections.
	#  * For Active Mode FTP the client must accept RELATED connections from the server on port 20
	#    to the client on a port number negotiated in the FTP control connection.
	#  * For Passive Mode FTP the client starts a RELATED connection from a random own high port number
	#    to the server's fixed high port number negotiated in the FTP control connection.
	#  * For both Active and Passive Mode FTP, the nf_conntrack_ftp kernel module is required at the FTP client
	#    to pick up the negotiated port number from the FTP control packet payloads.
	#
	iptables -A INPUT  -i "${EXT_INTERFACE}" -p tcp --sport 20                  -m state --state ESTABLISHED,RELATED -j ACCEPT # Active Mode
	iptables -A OUTPUT -o "${EXT_INTERFACE}" -p tcp --dport 20                  -m state --state ESTABLISHED         -j ACCEPT # Active Mode
	iptables -A OUTPUT -o "${EXT_INTERFACE}" -p tcp --sport 1024: --dport 1024: -m state --state ESTABLISHED,RELATED -j ACCEPT # Passive Mode
	iptables -A INPUT  -i "${EXT_INTERFACE}" -p tcp --sport 1024: --dport 1024: -m state --state ESTABLISHED         -j ACCEPT # Passive Mode
{% endif%}
{% if iptables_allow_aspera_outbound is defined and iptables_allow_aspera_outbound | length > 0 %}
	#
	# Allow Aspera outbound.
	#
	# Aspera requires (most common configs):
	#  * SSH on either TCP port 22 or TCP 33001 for control and
	#  * Data stream on at least UDP port 33001.
	#    In case the server OS doesn't allow UDP port sharing a range of UDP ports is used
	#    where the number of ports determines the max number of concurrent connections/clients.
	#
	declare -a ALLOW_ASPERA_OUTBOUND=(
	{% for ip in iptables_allow_aspera_outbound %}
		{% if ip == 'ANY'%}
		'0.0.0.0/0'
		{% else %}
		'{{ ip.address }}{{ ip.netmask }}'{% if ip.fqdn is defined and ip.fqdn != "NXDOMAIN" %}	# {{ ip.fqdn }}{% elif ip.desc is defined %}	# {{ ip.desc }}{% endif +%}
		{% endif %}
	{% endfor %}
	)
	for IP_ADDRESS in "${ALLOW_ASPERA_OUTBOUND[@]}"; do
		iptables -A OUTPUT -o "${EXT_INTERFACE}" -p tcp -d "${IP_ADDRESS}" -m multiport --dports 22,33001    -m state --state NEW,ESTABLISHED -j ACCEPT
		iptables -A OUTPUT -o "${EXT_INTERFACE}" -p udp -d "${IP_ADDRESS}" -m multiport --dports 33001:33100 -m state --state NEW,ESTABLISHED -j ACCEPT
	done
	iptables -A INPUT -i "${EXT_INTERFACE}" -p tcp -m multiport --sports 22,33001    -m state --state ESTABLISHED -j ACCEPT
	iptables -A INPUT -i "${EXT_INTERFACE}" -p udp -m multiport --sports 33001:33100 -m state --state ESTABLISHED -j ACCEPT
{% endif%}
{% if iptables_allow_globus_outbound is defined and iptables_allow_globus_outbound | length > 0 %}
	#
	# Allow Globus outbound.
	#
	# Globus requires (most common configs) for "broker" service:
	#  * TCP port  2223        outbound for control channel with the Globus Transfer service and for obtaining certificates during initial setup.
	#                          Normally this will be the *.globus.org subnet.
	#  * UDP port 19302        outbound for connecting to STUN server when setting up a session with another Globus Connect Personal endpoint.
	#                          Normally this will be the stun.l.google.com Google STUN server.
	# For each endpoint:
	#  * TCP ports 50000-51000 outbound for data channel for transfers with Globus Connect Server endpoints.
	#  * UDP ports 32768-65535 outbound for data channel for transfers with other Globus Connect Personal endpoints.
	#
	declare -a ALLOW_GLOBUS_OUTBOUND=(
	{% for ip in iptables_allow_globus_outbound %}
		{% if ip == 'ANY'%}
		'0.0.0.0/0'
		{% else %}
		'{{ ip.address }}{{ ip.netmask }}'{% if ip.fqdn is defined and ip.fqdn != "NXDOMAIN" %}	# {{ ip.fqdn }}{% elif ip.desc is defined %}	# {{ ip.desc }}{% endif +%}
		{% endif %}
	{% endfor %}
	)
	declare GLOBUS_ORG_NET='{{ all.ip_addresses['globus_org']['net']['address'] }}{{ all.ip_addresses['globus_org']['net']['netmask'] }}'	# {{ all.ip_addresses['globus_org']['net']['desc'] }}
	declare GOOGLE_STUN='{{ all.ip_addresses['google']['stun']['address'] }}{{ all.ip_addresses['google']['stun']['netmask'] }}'		# {{ all.ip_addresses['google']['stun']['desc'] }}
	iptables   -A OUTPUT -o "${EXT_INTERFACE}" -p tcp -d "${GLOBUS_ORG_NET}"            --dport 2223  -m state --state NEW,ESTABLISHED -j ACCEPT
	iptables   -A OUTPUT -o "${EXT_INTERFACE}" -p udp -d "${GOOGLE_STUN}"               --dport 19302 -m state --state NEW,ESTABLISHED -j ACCEPT
	for IP_ADDRESS in "${ALLOW_GLOBUS_OUTBOUND[@]}"; do
		iptables -A OUTPUT -o "${EXT_INTERFACE}" -p tcp -d "${IP_ADDRESS}" -m multiport --dports 50000:51000 -m state --state NEW,ESTABLISHED -j ACCEPT
		iptables -A OUTPUT -o "${EXT_INTERFACE}" -p udp -d "${IP_ADDRESS}" -m multiport --dports 32678:65535 -m state --state NEW,ESTABLISHED -j ACCEPT
	done
{% endif%}
{% if iptables_allow_irods is defined and iptables_allow_irods | length > 0 %}
	#
	# Allow iRODS both inbound and outbound.
	#
	# iRODS requires:
	#  * TCP port 1247: Handshakes and data transfers.
	#  * TCP port 1248: Control Plane.
	#  * TCP ports 20000-20199: Dynamically allocated for direct machine to machine connections for large data transfers.
	#  * The iCAT requires a DataBase too, which is usually a PostgreSQL DB. Do not forget to open the corresponding port too.
	#
	declare -a ALLOW_IRODS=(
	{% for ip in iptables_allow_irods %}
		{% if ip == 'ANY'%}
		'0.0.0.0/0'
		{% else %}
		'{{ ip.address }}{{ ip.netmask }}'{% if ip.fqdn is defined and ip.fqdn != "NXDOMAIN" %}	# {{ ip.fqdn }}{% elif ip.desc is defined %}	# {{ ip.desc }}{% endif +%}
		{% endif %}
	{% endfor %}
	)
	for IP_ADDRESS in "${ALLOW_IRODS[@]}"; do
		iptables -A INPUT  -i "${EXT_INTERFACE}" -p tcp -s "${IP_ADDRESS}" -m multiport --ports 1247,1248,20000:20199 -m state --state NEW,ESTABLISHED -j ACCEPT
		iptables -A OUTPUT -o "${EXT_INTERFACE}" -p tcp -d "${IP_ADDRESS}" -m multiport --ports 1247,1248,20000:20199 -m state --state NEW,ESTABLISHED -j ACCEPT
	done
{% endif%}
	#
	# Allow outbound logs.
	#
	iptables -A OUTPUT -o "${EXT_INTERFACE}" -p tcp --dport 41514 -m state --state NEW,ESTABLISHED -j ACCEPT
	iptables -A INPUT  -i "${EXT_INTERFACE}" -p tcp --sport 41514 -m state --state ESTABLISHED     -j ACCEPT
{% if iptables_allow_logs_inbound is defined and iptables_allow_logs_inbound | length > 0 %}
	#
	# Allow inbound logs.
	#
	# logs requires:
	#  * TCP port 41514: to receive syslogs
	#
	declare -a ALLOW_LOGS_INBOUND=(
	{% for ip in iptables_allow_logs_inbound %}
		{% if ip == 'ANY'%}
		'0.0.0.0/0'
		{% else %}
		'{{ ip.address }}{{ ip.netmask }}'{% if ip.fqdn is defined and ip.fqdn != "NXDOMAIN" %}	# {{ ip.fqdn }}{% elif ip.desc is defined %}	# {{ ip.desc }}{% endif +%}
		{% endif %}
	{% endfor %}
	)
	for IP_ADDRESS in "${ALLOW_LOGS_INBOUND[@]}"; do
		iptables -A INPUT  -i "${EXT_INTERFACE}" -p tcp -s "${IP_ADDRESS}" --dport 41514 -m state --state NEW,ESTABLISHED -j ACCEPT
	done
	iptables -A OUTPUT -o "${EXT_INTERFACE}" -p tcp --sport 41514 -m state --state ESTABLISHED -j ACCEPT
{% endif%}
{% if iptables_allow_ldap_inbound is defined and iptables_allow_ldap_inbound | length > 0 %}
	#
	# Allow inbound ldap.
	#
	# ldap requires:
	#  * TCP port 636: to receive LDAP
	#
	declare -a ALLOW_LDAP_INBOUND=(
	{% for ip in iptables_allow_ldap_inbound %}
		{% if ip == 'ANY'%}
		'0.0.0.0/0'
		{% else %}
		'{{ ip.address }}{{ ip.netmask }}'{% if ip.fqdn is defined and ip.fqdn != "NXDOMAIN" %}	# {{ ip.fqdn }}{% elif ip.desc is defined %}	# {{ ip.desc }}{% endif +%}
		{% endif %}
	{% endfor %}
	)
	for IP_ADDRESS in "${ALLOW_LDAP_INBOUND[@]}"; do
		iptables -A INPUT  -i "${EXT_INTERFACE}" -p tcp -s "${IP_ADDRESS}" --dport 636 -m state --state NEW,ESTABLISHED -j ACCEPT
	done
	iptables -A OUTPUT -o "${EXT_INTERFACE}" -p tcp --sport 636 -m state --state ESTABLISHED -j ACCEPT
{% endif%}
done

#
## IP & PORT exception whitelist
# Inside the (default) /etc/iptables_extras.d/ directory, check for the whitelist files (name ending with .allow)
# parse through and look for format '{IP}{one or more spaces}{PORT}', then create 'iptables' exceptions for those.
# When needed, ansible roles will create this directory and is ignored otherwise.
#
if [[ -d {{ iptables_extras_dir }}  ]]; then
   # Loop collect content from every stack *.allow file, sort and get unique values only
   IPTABLES_EXCEPTIONS="$(cat {{ iptables_extras_dir }}/*.allow | sort | uniq)"
   declare -a ALLOW_EXCEPTIONS
   # Use only the lines in the format of "^(IP address)(one or more spaces)(PORT number)$"
   IPTABLES_FILTER_EXCEPTIONS="$(echo "${IPTABLES_EXCEPTIONS}" | grep -E '^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}[[:blank:]]+[0-9]{1,5}$')"
   readarray -t ALLOW_EXCEPTIONS <<< "${IPTABLES_FILTER_EXCEPTIONS:-}"
   for EACH_EXCEPTION_LINE in "${ALLOW_EXCEPTIONS[@]}"; do
      IP_ADDRESS="$(echo "${EACH_EXCEPTION_LINE:-}" | awk '{print $1}')"
      PORT_NUMBER="$(echo "${EACH_EXCEPTION_LINE:-}" | awk '{print $2}')"
      iptables -A INPUT -p tcp -s "${IP_ADDRESS}" --dport "${PORT_NUMBER}" -m state --state NEW,ESTABLISHED -j ACCEPT
   done
fi

#
# (Re)start fail2ban, so it will (re)create a custom f2b-SSH iptables chain.
#
#service fail2ban restart

#
# List the rules:
#
echo '#'
echo '##'
echo '### iptables --list -n ###'
echo '##'
echo '#'
iptables --list -n
echo '#'
echo '##'
echo '### ip6tables --list -n ###'
echo '##'
echo '#'
ip6tables --list -n

#
# Save config for next boot.
#
service iptables save
service ip6tables save
